{
  "type": "functionInvocation",
  "identifier": {
    "type": "identifier",
    "value": "$",
    "text": "$",
    "offset": 1,
    "lineBreaks": 0,
    "line": 1,
    "col": 2
  },
  "children": [
    {
      "type": "text",
      "value": "authorx is a tool-chain for creating markdown-like languages.\n\n",
      "text": "authorx is a tool-chain for creating markdown-like languages.\n\n",
      "offset": 5,
      "lineBreaks": 2,
      "line": 2,
      "col": 1
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": "#",
        "text": "#",
        "offset": 69,
        "lineBreaks": 0,
        "line": 4,
        "col": 2
      },
      "children": [
        {
          "type": "text",
          "value": "Why? ",
          "text": "Why? ",
          "offset": 73,
          "lineBreaks": 0,
          "line": 4,
          "col": 6
        }
      ]
    },
    {
      "type": "whitespace",
      "children": [
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 79,
          "lineBreaks": 1,
          "line": 4,
          "col": 12
        },
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 80,
          "lineBreaks": 1,
          "line": 5,
          "col": 1
        }
      ]
    },
    {
      "type": "text",
      "value": "While its nice to write simple documents in markdown, anything relatively sophisticated (e.g., blogs, interactive explanations, interactive computing notebooks) requires using and/or implementing ad-hoc extensions to markdown. Implementing and using these extensions is difficult because: \n\n",
      "text": "While its nice to write simple documents in markdown, anything relatively sophisticated (e.g., blogs, interactive explanations, interactive computing notebooks) requires using and/or implementing ad-hoc extensions to markdown. Implementing and using these extensions is difficult because: \n\n",
      "offset": 81,
      "lineBreaks": 2,
      "line": 6,
      "col": 1
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": "l",
        "text": "l",
        "offset": 373,
        "lineBreaks": 0,
        "line": 8,
        "col": 2
      },
      "children": [
        {
          "type": "functionInvocation",
          "identifier": {
            "type": "identifier",
            "value": "<",
            "text": "<",
            "offset": 378,
            "lineBreaks": 0,
            "line": 9,
            "col": 2
          },
          "children": [
            {
              "type": "text",
              "value": "Markdown ",
              "text": "Markdown ",
              "offset": 382,
              "lineBreaks": 0,
              "line": 9,
              "col": 6
            },
            {
              "type": "functionInvocation",
              "identifier": {
                "type": "identifier",
                "value": "a",
                "text": "a",
                "offset": 392,
                "lineBreaks": 0,
                "line": 9,
                "col": 16
              },
              "argList": [
                {
                  "type": "argument",
                  "value": "https://roopc.net/posts/2014/markdown-cfg/",
                  "text": "https://roopc.net/posts/2014/markdown-cfg/",
                  "offset": 394,
                  "lineBreaks": 0,
                  "line": 9,
                  "col": 18
                }
              ],
              "children": [
                {
                  "type": "text",
                  "value": "has an ambiguous grammar ",
                  "text": "has an ambiguous grammar ",
                  "offset": 440,
                  "lineBreaks": 0,
                  "line": 9,
                  "col": 64
                }
              ]
            },
            {
              "type": "whitespace",
              "children": [
                {
                  "type": "ws",
                  "value": " ",
                  "text": " ",
                  "offset": 466,
                  "lineBreaks": 0,
                  "line": 9,
                  "col": 90
                }
              ]
            },
            {
              "type": "text",
              "value": "and therefore multiple implementations of parsing and rendering. ",
              "text": "and therefore multiple implementations of parsing and rendering. ",
              "offset": 467,
              "lineBreaks": 0,
              "line": 9,
              "col": 91
            }
          ]
        },
        {
          "type": "whitespace",
          "children": [
            {
              "type": "ws",
              "value": "\n",
              "text": "\n",
              "offset": 533,
              "lineBreaks": 1,
              "line": 9,
              "col": 157
            }
          ]
        },
        {
          "type": "functionInvocation",
          "identifier": {
            "type": "identifier",
            "value": "<",
            "text": "<",
            "offset": 535,
            "lineBreaks": 0,
            "line": 10,
            "col": 2
          },
          "children": [
            {
              "type": "text",
              "value": "Not all programming languages have markdown parsers that offer extension points, and even when they do, those extension points often make it feel messier to write in markdown. ",
              "text": "Not all programming languages have markdown parsers that offer extension points, and even when they do, those extension points often make it feel messier to write in markdown. ",
              "offset": 539,
              "lineBreaks": 0,
              "line": 10,
              "col": 6
            }
          ]
        },
        {
          "type": "whitespace",
          "children": [
            {
              "type": "ws",
              "value": "\n",
              "text": "\n",
              "offset": 716,
              "lineBreaks": 1,
              "line": 10,
              "col": 183
            }
          ]
        },
        {
          "type": "functionInvocation",
          "identifier": {
            "type": "identifier",
            "value": "<",
            "text": "<",
            "offset": 718,
            "lineBreaks": 0,
            "line": 11,
            "col": 2
          },
          "children": [
            {
              "type": "text",
              "value": "You can't arbitrarily nest tagged/transformed text in markdown, so it's inherently limited as a language. ",
              "text": "You can't arbitrarily nest tagged/transformed text in markdown, so it's inherently limited as a language. ",
              "offset": 722,
              "lineBreaks": 0,
              "line": 11,
              "col": 6
            }
          ]
        },
        {
          "type": "whitespace",
          "children": [
            {
              "type": "ws",
              "value": "\n",
              "text": "\n",
              "offset": 829,
              "lineBreaks": 1,
              "line": 11,
              "col": 113
            }
          ]
        }
      ]
    },
    {
      "type": "whitespace",
      "children": [
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 831,
          "lineBreaks": 1,
          "line": 12,
          "col": 2
        },
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 832,
          "lineBreaks": 1,
          "line": 13,
          "col": 1
        }
      ]
    },
    {
      "type": "text",
      "value": "authorx makes it easy to create markdown-like languages that work for more complicated publishing formats.\n\n",
      "text": "authorx makes it easy to create markdown-like languages that work for more complicated publishing formats.\n\n",
      "offset": 833,
      "lineBreaks": 2,
      "line": 14,
      "col": 1
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": "#",
        "text": "#",
        "offset": 942,
        "lineBreaks": 0,
        "line": 16,
        "col": 2
      },
      "children": [
        {
          "type": "text",
          "value": "How? ",
          "text": "How? ",
          "offset": 946,
          "lineBreaks": 0,
          "line": 16,
          "col": 6
        }
      ]
    },
    {
      "type": "whitespace",
      "children": [
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 952,
          "lineBreaks": 1,
          "line": 16,
          "col": 12
        },
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 953,
          "lineBreaks": 1,
          "line": 17,
          "col": 1
        }
      ]
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": "##",
        "text": "##",
        "offset": 955,
        "lineBreaks": 0,
        "line": 18,
        "col": 2
      },
      "children": [
        {
          "type": "text",
          "value": "Simple, unambiguous grammar ",
          "text": "Simple, unambiguous grammar ",
          "offset": 960,
          "lineBreaks": 0,
          "line": 18,
          "col": 7
        }
      ]
    },
    {
      "type": "whitespace",
      "children": [
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 989,
          "lineBreaks": 1,
          "line": 18,
          "col": 36
        },
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 990,
          "lineBreaks": 1,
          "line": 19,
          "col": 1
        }
      ]
    },
    {
      "type": "text",
      "value": "There's only two syntactic elements to authorx documents: text and functions that transform text. Hello world looks like this:\n\n",
      "text": "There's only two syntactic elements to authorx documents: text and functions that transform text. Hello world looks like this:\n\n",
      "offset": 991,
      "lineBreaks": 2,
      "line": 20,
      "col": 1
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": ">",
        "text": ">",
        "offset": 1120,
        "lineBreaks": 0,
        "line": 22,
        "col": 2
      },
      "children": [
        {
          "type": "text",
          "value": "\\<p {\n    Hello, world!\n  \\}\n",
          "text": "\\<p {\n    Hello, world!\n  \\}\n",
          "offset": 1126,
          "lineBreaks": 3,
          "line": 23,
          "col": 3
        }
      ]
    },
    {
      "type": "whitespace",
      "children": [
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 1156,
          "lineBreaks": 1,
          "line": 26,
          "col": 2
        },
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 1157,
          "lineBreaks": 1,
          "line": 27,
          "col": 1
        }
      ]
    },
    {
      "type": "text",
      "value": "You can see the grammar ",
      "text": "You can see the grammar ",
      "offset": 1158,
      "lineBreaks": 0,
      "line": 28,
      "col": 1
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": "a",
        "text": "a",
        "offset": 1183,
        "lineBreaks": 0,
        "line": 28,
        "col": 26
      },
      "argList": [
        {
          "type": "argument",
          "value": "./grammar.ne",
          "text": "./grammar.ne",
          "offset": 1185,
          "lineBreaks": 0,
          "line": 28,
          "col": 28
        }
      ],
      "children": [
        {
          "type": "text",
          "value": "here ",
          "text": "here ",
          "offset": 1201,
          "lineBreaks": 0,
          "line": 28,
          "col": 44
        }
      ]
    },
    {
      "type": "text",
      "value": ".\n\n",
      "text": ".\n\n",
      "offset": 1207,
      "lineBreaks": 2,
      "line": 28,
      "col": 50
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": "##",
        "text": "##",
        "offset": 1211,
        "lineBreaks": 0,
        "line": 30,
        "col": 2
      },
      "children": [
        {
          "type": "text",
          "value": "Syntax is separate from semantics ",
          "text": "Syntax is separate from semantics ",
          "offset": 1216,
          "lineBreaks": 0,
          "line": 30,
          "col": 7
        }
      ]
    },
    {
      "type": "whitespace",
      "children": [
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 1251,
          "lineBreaks": 1,
          "line": 30,
          "col": 42
        },
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 1252,
          "lineBreaks": 1,
          "line": 31,
          "col": 1
        }
      ]
    },
    {
      "type": "text",
      "value": "Functions in authorx have no meaning by default. This means that the above hello world example that calls the \"p\" function may create a simple html paragraph or it may display the text inside a div with pink background. It's your call. With authorx, semantics are added by defining the text-transformation functions in js and passing them to the compiler:\n\n",
      "text": "Functions in authorx have no meaning by default. This means that the above hello world example that calls the \"p\" function may create a simple html paragraph or it may display the text inside a div with pink background. It's your call. With authorx, semantics are added by defining the text-transformation functions in js and passing them to the compiler:\n\n",
      "offset": 1253,
      "lineBreaks": 2,
      "line": 32,
      "col": 1
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": ">",
        "text": ">",
        "offset": 1611,
        "lineBreaks": 0,
        "line": 34,
        "col": 2
      },
      "argList": [
        {
          "type": "argument",
          "value": "js",
          "text": "js",
          "offset": 1613,
          "lineBreaks": 0,
          "line": 34,
          "col": 4
        }
      ],
      "children": [
        {
          "type": "text",
          "value": "import \\{ compile \\} from \"authorx\";\n\n  compile((identifer) => \\{\n    switch(identifer) \\{\n      case \"p\":\n        return (text) => `\\<p>$\\{text\\}\\<\\\\p>`\n    \\}\n  \\});\n",
          "text": "import \\{ compile \\} from \"authorx\";\n\n  compile((identifer) => \\{\n    switch(identifer) \\{\n      case \"p\":\n        return (text) => `\\<p>$\\{text\\}\\<\\\\p>`\n    \\}\n  \\});\n",
          "offset": 1621,
          "lineBreaks": 8,
          "line": 35,
          "col": 3
        }
      ]
    },
    {
      "type": "whitespace",
      "children": [
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 1790,
          "lineBreaks": 1,
          "line": 43,
          "col": 2
        },
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 1791,
          "lineBreaks": 1,
          "line": 44,
          "col": 1
        }
      ]
    },
    {
      "type": "text",
      "value": "In fact, this markdown README file was generated from a README.ax file, where the functions look like markdown tags:\n\n",
      "text": "In fact, this markdown README file was generated from a README.ax file, where the functions look like markdown tags:\n\n",
      "offset": 1792,
      "lineBreaks": 2,
      "line": 45,
      "col": 1
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": ">",
        "text": ">",
        "offset": 1911,
        "lineBreaks": 0,
        "line": 47,
        "col": 2
      },
      "children": [
        {
          "type": "text",
          "value": "\\<# \\{ How? \\}\n\n\\<## \\{ Syntax is separate from semantics \\} \n\nYou can see the grammar \\<a(./grammar.ne) \\{ here \\}.\n\n\\<l \\{\n\\<\\< \\{ Markdown \\<a(https://roopc.net/posts/2014/markdown-cfg/) \\{ has an ambiguous grammar \\} and therefore multiple implementations of parsing and rendering. \\}\n\\<\\< \\{ Not all programming languages have markdown parsers that offer extension points, and even when they do, those extension points often make it feel messier to write in markdown. \\}\n\\<\\< \\{ You can't arbitrarily nest tagged/transformed text in markdown, so it's inherently limited as a language. \\}\n\\}\n",
          "text": "\\<# \\{ How? \\}\n\n\\<## \\{ Syntax is separate from semantics \\} \n\nYou can see the grammar \\<a(./grammar.ne) \\{ here \\}.\n\n\\<l \\{\n\\<\\< \\{ Markdown \\<a(https://roopc.net/posts/2014/markdown-cfg/) \\{ has an ambiguous grammar \\} and therefore multiple implementations of parsing and rendering. \\}\n\\<\\< \\{ Not all programming languages have markdown parsers that offer extension points, and even when they do, those extension points often make it feel messier to write in markdown. \\}\n\\<\\< \\{ You can't arbitrarily nest tagged/transformed text in markdown, so it's inherently limited as a language. \\}\n\\}\n",
          "offset": 1915,
          "lineBreaks": 11,
          "line": 48,
          "col": 1
        }
      ]
    },
    {
      "type": "whitespace",
      "children": [
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 2512,
          "lineBreaks": 1,
          "line": 59,
          "col": 2
        },
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 2513,
          "lineBreaks": 1,
          "line": 60,
          "col": 1
        }
      ]
    }
  ]
}
