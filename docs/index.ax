<$ {

<! {
  I don't recommend using authorx for serious projects yet.
  You can view the roadmap to 1.0 <a(#project-status--roadmap) { here }.
}


<# Table of Contents

<l {
<< { <a(#why) { Why? } }
<< { <a(#how) { How? } }
<< { <a(#quick-start) { Quickstart } }
<< { <a(#project-status--roadmap) { Status & Roadmap } }
}

<# Why?

While its nice to write simple documents in markdown, writing anything relatively sophisticated (e.g., blogs, technical documentation, interactive content) is a pain. 

For example, consider the red warning panel at the top of this doc that says you shouldn't use authorx for serious projects. The only way to create something like that in markdown is to embed html into your markdown doc:

<>(md) {:

<div <!-- ... --> >
  <div>
    <svg
      <!-- ... -->
    >
      <path <!-- ... --> />
    </svg>
  </div>
  <p <!-- ... --> >I don't recommend using authorx for serious projects yet.
  You can view the roadmap to 1.0 <a href="#project-status--roadmap">here</a>.
  </p>
</div>

# Table of Contents

:}

With authorx, you <* { could } create a warning info panel like this:

<>{:
<! {
  I don't recommend using authorx for serious projects yet.
  You can view the roadmap to 1.0 <a(#project-status--roadmap) { here }.
}
:}

Note that with authorx we can arbitrarily nest transformed content. Here we have a link inside of a warning panel.

Here's another example: say you wanted to embed a <a(https://mermaid-js.github.io/mermaid/#/) { mermaid.js } diagram into your doc like <a(#syntax-is-separate-from-semantics) { the one below }. If you're just using markdown, you'll have to write your mermaid diagram, run the cli, and then include a reference to the generated image in your markdown. With authorx, you can embed mermaid diagrams like this:

<>{:
<~ {
  graph LR
  A[.ax file] -->|parse| B(AST)
  B --> C("authorx-extensions e.g., x-faux-markdown x-mermaid-js")
  C -->D(your extensions)
  D -->E(".html | .md | .*")
}
:}

I've been emphasizing <* { could } in these examples because the way authorx documents work is largely up to you. With authorx, syntax and semantics are separate. The <` { \<~ } in the above example is just a function. You define what the function does in javascript. Maybe it embeds a mermaid diagram into your document. Maybe it floats content to the left side of the page. It's up to you. 

With authorx's minimal and expressive syntax and your function definitions, you can create markdown-like languages that work for more rich and interactive content. All you have to do is define the functions.

<# How?

<## Simple grammar

There's only two syntactic elements to authorx documents: text and functions that transform text. Hello world looks like this:

<> {:
<p Hello, world!
:}

You can see the grammar <a(https://github.com/kmdupr33/authorx/blob/master/packages/compiler/lib/grammar.ne) { here }.

<## { Syntax is separate from semantics }

Functions in authorx have no meaning by default. With authorx, semantics are added by defining the text-transformation functions in js and passing them to the compiler:

<>(js) {:
import { compile } from "@authorx/compiler";

compile("path-to-ax-file", {
  "#": (text) => `<h1>${text}</h1>`
});
:}

Here's the high-level flow of how <` { compile } transforms text to its final format:

<~ {
  graph LR
  A[.ax file] -->|parse| B(AST)
  B --> C("authorx-extensions e.g., x-faux-markdown x-mermaid-js")
  C -->D(your extensions)
  D -->E(".html | .md | .*")
}

In fact, this markdown README file was generated from <a(./README.ax) { a README.ax file }, where the functions look like markdown tags:

<> {:
<# How?

<## Syntax is separate from semantics  

You can see the grammar <a(./grammar.ne) { here }.

<l {
<< We often need to use awkward, ad-hoc extensions to markdown. Take "front-matter" in static site generators, for example.
<< There are some things we just can't do with markdown because it doesn't allow arbitrary nesting of tagged/transformed text. We wind up embedding markdown in html or in some sort of template system.
}
:}

The markdown-like functions that generated this readme are defined in the <a(https://github.com/kmdupr33/authorx/tree/master/packages/x-faux-markdown) { x-faux-markdown package }

<# Quick Start 

<>{:
npm i @authorx/compiler
:}

Let's write hello world in a <` { hello.ax } file:

<> {:
<# hello world
:}

Next, we'll create an empty <` { my-markdown.js } file, with details to be filled in later:

<>(bash) {:
touch my-markdown.js
:}

You can use the compiler right away, but all it'll do is print out hello world:

<>(bash) {:
npx axc hello.ax my-markdown.js
# outputs "hello world"
:}

If you want "\<#" to wrap "hello world" in h1 headings like markdown does, add this to your <` { my-markdown.js } file

<>(js) {:
module.exports = { 
  '#': (text) => '<h1>' + text + '</h1>' 
}  
:}

Now, when you run <` { axc }, you'll see that hello world is wrapped in h1 tags:

<>(bash) {:
npx axc hello.ax my-markdown.js
# outputs <h1>hello world</h1>
:}

If you don't want to rewrite markdown-esque functions, you can <` { npm i @authorx/x-faux-markdown } and extend those functions trivially:

<>(js) {:
// my-markdown.js
const xFauxMarkdown = require("@authorx/x-faux-markdown")
module.exports = {
  // Your custom functions here
  ...xFauxMarkdown()  
}
:}

Then just rerun <` { axc } and point it to your updated file:

<>(bash) {:
npx axc hello.ax my-markdown.js
:}

<# Project Status & Roadmap 

authorx is in rough shape currently. The syntax isn't even as clean as I'd like it, but I'm working on <a(https://github.com/kmdupr33/authorx/blob/master/Roadmap.ax) { the roadmap }. Feel free to file issues. Would love to hear your feedback.

}