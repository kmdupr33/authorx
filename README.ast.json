{
  "type": "functionInvocation",
  "identifier": {
    "type": "identifier",
    "value": "$",
    "text": "$",
    "offset": 1,
    "lineBreaks": 0,
    "line": 1,
    "col": 2
  },
  "children": [
    {
      "type": "text",
      "value": "authorx is a tool-chain for creating markdown-like languages.\n\n",
      "text": "authorx is a tool-chain for creating markdown-like languages.\n\n",
      "offset": 5,
      "lineBreaks": 2,
      "line": 2,
      "col": 1
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": "#",
        "text": "#",
        "offset": 69,
        "lineBreaks": 0,
        "line": 4,
        "col": 2
      },
      "children": [
        {
          "type": "text",
          "value": "Why? ",
          "text": "Why? ",
          "offset": 73,
          "lineBreaks": 0,
          "line": 4,
          "col": 6
        }
      ]
    },
    {
      "type": "whitespace",
      "children": [
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 79,
          "lineBreaks": 1,
          "line": 4,
          "col": 12
        },
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 80,
          "lineBreaks": 1,
          "line": 5,
          "col": 1
        }
      ]
    },
    {
      "type": "text",
      "value": "While its nice to write simple documents in markdown, anything relatively sophisticated (e.g., blogs, technical documentation, interactive explanations, interactive computing notebooks) requires using and/or implementing ad-hoc extensions to markdown. Implementing and using these extensions is difficult because: \n\n",
      "text": "While its nice to write simple documents in markdown, anything relatively sophisticated (e.g., blogs, technical documentation, interactive explanations, interactive computing notebooks) requires using and/or implementing ad-hoc extensions to markdown. Implementing and using these extensions is difficult because: \n\n",
      "offset": 81,
      "lineBreaks": 2,
      "line": 6,
      "col": 1
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": "l",
        "text": "l",
        "offset": 398,
        "lineBreaks": 0,
        "line": 8,
        "col": 2
      },
      "children": [
        {
          "type": "functionInvocation",
          "identifier": {
            "type": "identifier",
            "value": "<",
            "text": "<",
            "offset": 403,
            "lineBreaks": 0,
            "line": 9,
            "col": 2
          },
          "children": [
            {
              "type": "text",
              "value": "Markdown ",
              "text": "Markdown ",
              "offset": 407,
              "lineBreaks": 0,
              "line": 9,
              "col": 6
            },
            {
              "type": "functionInvocation",
              "identifier": {
                "type": "identifier",
                "value": "a",
                "text": "a",
                "offset": 417,
                "lineBreaks": 0,
                "line": 9,
                "col": 16
              },
              "argList": [
                {
                  "type": "argument",
                  "value": "https://roopc.net/posts/2014/markdown-cfg/",
                  "text": "https://roopc.net/posts/2014/markdown-cfg/",
                  "offset": 419,
                  "lineBreaks": 0,
                  "line": 9,
                  "col": 18
                }
              ],
              "children": [
                {
                  "type": "text",
                  "value": "has an ambiguous grammar ",
                  "text": "has an ambiguous grammar ",
                  "offset": 465,
                  "lineBreaks": 0,
                  "line": 9,
                  "col": 64
                }
              ]
            },
            {
              "type": "whitespace",
              "children": [
                {
                  "type": "ws",
                  "value": " ",
                  "text": " ",
                  "offset": 491,
                  "lineBreaks": 0,
                  "line": 9,
                  "col": 90
                }
              ]
            },
            {
              "type": "text",
              "value": "and therefore multiple implementations of parsing and rendering. ",
              "text": "and therefore multiple implementations of parsing and rendering. ",
              "offset": 492,
              "lineBreaks": 0,
              "line": 9,
              "col": 91
            }
          ]
        },
        {
          "type": "whitespace",
          "children": [
            {
              "type": "ws",
              "value": "\n",
              "text": "\n",
              "offset": 558,
              "lineBreaks": 1,
              "line": 9,
              "col": 157
            }
          ]
        },
        {
          "type": "functionInvocation",
          "identifier": {
            "type": "identifier",
            "value": "<",
            "text": "<",
            "offset": 560,
            "lineBreaks": 0,
            "line": 10,
            "col": 2
          },
          "children": [
            {
              "type": "text",
              "value": "Not all programming languages have markdown parsers that offer extension points, and even when they do, those extension points often make it feel messier to write in markdown. ",
              "text": "Not all programming languages have markdown parsers that offer extension points, and even when they do, those extension points often make it feel messier to write in markdown. ",
              "offset": 564,
              "lineBreaks": 0,
              "line": 10,
              "col": 6
            }
          ]
        },
        {
          "type": "whitespace",
          "children": [
            {
              "type": "ws",
              "value": "\n",
              "text": "\n",
              "offset": 741,
              "lineBreaks": 1,
              "line": 10,
              "col": 183
            }
          ]
        },
        {
          "type": "functionInvocation",
          "identifier": {
            "type": "identifier",
            "value": "<",
            "text": "<",
            "offset": 743,
            "lineBreaks": 0,
            "line": 11,
            "col": 2
          },
          "children": [
            {
              "type": "text",
              "value": "You can't arbitrarily nest tagged/transformed text in markdown, so it's inherently limited as a language. ",
              "text": "You can't arbitrarily nest tagged/transformed text in markdown, so it's inherently limited as a language. ",
              "offset": 747,
              "lineBreaks": 0,
              "line": 11,
              "col": 6
            }
          ]
        },
        {
          "type": "whitespace",
          "children": [
            {
              "type": "ws",
              "value": "\n",
              "text": "\n",
              "offset": 854,
              "lineBreaks": 1,
              "line": 11,
              "col": 113
            }
          ]
        }
      ]
    },
    {
      "type": "whitespace",
      "children": [
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 856,
          "lineBreaks": 1,
          "line": 12,
          "col": 2
        },
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 857,
          "lineBreaks": 1,
          "line": 13,
          "col": 1
        }
      ]
    },
    {
      "type": "text",
      "value": "authorx makes it easy to create markdown-like languages that work for more complicated publishing formats.\n\n",
      "text": "authorx makes it easy to create markdown-like languages that work for more complicated publishing formats.\n\n",
      "offset": 858,
      "lineBreaks": 2,
      "line": 14,
      "col": 1
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": "#",
        "text": "#",
        "offset": 967,
        "lineBreaks": 0,
        "line": 16,
        "col": 2
      },
      "children": [
        {
          "type": "text",
          "value": "How? ",
          "text": "How? ",
          "offset": 971,
          "lineBreaks": 0,
          "line": 16,
          "col": 6
        }
      ]
    },
    {
      "type": "whitespace",
      "children": [
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 977,
          "lineBreaks": 1,
          "line": 16,
          "col": 12
        },
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 978,
          "lineBreaks": 1,
          "line": 17,
          "col": 1
        }
      ]
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": "##",
        "text": "##",
        "offset": 980,
        "lineBreaks": 0,
        "line": 18,
        "col": 2
      },
      "children": [
        {
          "type": "text",
          "value": "Simple, unambiguous grammar ",
          "text": "Simple, unambiguous grammar ",
          "offset": 985,
          "lineBreaks": 0,
          "line": 18,
          "col": 7
        }
      ]
    },
    {
      "type": "whitespace",
      "children": [
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 1014,
          "lineBreaks": 1,
          "line": 18,
          "col": 36
        },
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 1015,
          "lineBreaks": 1,
          "line": 19,
          "col": 1
        }
      ]
    },
    {
      "type": "text",
      "value": "There's only two syntactic elements to authorx documents: text and functions that transform text. Hello world looks like this:\n\n",
      "text": "There's only two syntactic elements to authorx documents: text and functions that transform text. Hello world looks like this:\n\n",
      "offset": 1016,
      "lineBreaks": 2,
      "line": 20,
      "col": 1
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": ">",
        "text": ">",
        "offset": 1145,
        "lineBreaks": 0,
        "line": 22,
        "col": 2
      },
      "children": [
        {
          "type": "text",
          "value": "\\<p {\n    Hello, world!\n  \\}\n",
          "text": "\\<p {\n    Hello, world!\n  \\}\n",
          "offset": 1151,
          "lineBreaks": 3,
          "line": 23,
          "col": 3
        }
      ]
    },
    {
      "type": "whitespace",
      "children": [
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 1181,
          "lineBreaks": 1,
          "line": 26,
          "col": 2
        },
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 1182,
          "lineBreaks": 1,
          "line": 27,
          "col": 1
        }
      ]
    },
    {
      "type": "text",
      "value": "You can see the grammar ",
      "text": "You can see the grammar ",
      "offset": 1183,
      "lineBreaks": 0,
      "line": 28,
      "col": 1
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": "a",
        "text": "a",
        "offset": 1208,
        "lineBreaks": 0,
        "line": 28,
        "col": 26
      },
      "argList": [
        {
          "type": "argument",
          "value": "./packages/compiler/lib/grammar.ne",
          "text": "./packages/compiler/lib/grammar.ne",
          "offset": 1210,
          "lineBreaks": 0,
          "line": 28,
          "col": 28
        }
      ],
      "children": [
        {
          "type": "text",
          "value": "here ",
          "text": "here ",
          "offset": 1248,
          "lineBreaks": 0,
          "line": 28,
          "col": 66
        }
      ]
    },
    {
      "type": "text",
      "value": ".\n\n",
      "text": ".\n\n",
      "offset": 1254,
      "lineBreaks": 2,
      "line": 28,
      "col": 72
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": "##",
        "text": "##",
        "offset": 1258,
        "lineBreaks": 0,
        "line": 30,
        "col": 2
      },
      "children": [
        {
          "type": "text",
          "value": "Syntax is separate from semantics ",
          "text": "Syntax is separate from semantics ",
          "offset": 1263,
          "lineBreaks": 0,
          "line": 30,
          "col": 7
        }
      ]
    },
    {
      "type": "whitespace",
      "children": [
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 1298,
          "lineBreaks": 1,
          "line": 30,
          "col": 42
        },
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 1299,
          "lineBreaks": 1,
          "line": 31,
          "col": 1
        }
      ]
    },
    {
      "type": "text",
      "value": "Functions in authorx have no meaning by default. This means that the above hello world example that calls the \"p\" function may create a simple html paragraph or it may display the text inside a div with pink background. It's your call. With authorx, semantics are added by defining the text-transformation functions in js and passing them to the compiler:\n\n",
      "text": "Functions in authorx have no meaning by default. This means that the above hello world example that calls the \"p\" function may create a simple html paragraph or it may display the text inside a div with pink background. It's your call. With authorx, semantics are added by defining the text-transformation functions in js and passing them to the compiler:\n\n",
      "offset": 1300,
      "lineBreaks": 2,
      "line": 32,
      "col": 1
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": ">",
        "text": ">",
        "offset": 1658,
        "lineBreaks": 0,
        "line": 34,
        "col": 2
      },
      "argList": [
        {
          "type": "argument",
          "value": "js",
          "text": "js",
          "offset": 1660,
          "lineBreaks": 0,
          "line": 34,
          "col": 4
        }
      ],
      "children": [
        {
          "type": "text",
          "value": "import \\{ compile \\} from \"@authorx/compiler\";\n\ncompile(\"path-to-ax-file\", \\{\n  \"p\": (string) => `\\<p\\>$\\{string\\}\\</p\\>`\n\\});\n",
          "text": "import \\{ compile \\} from \"@authorx/compiler\";\n\ncompile(\"path-to-ax-file\", \\{\n  \"p\": (string) => `\\<p\\>$\\{string\\}\\</p\\>`\n\\});\n",
          "offset": 1666,
          "lineBreaks": 5,
          "line": 35,
          "col": 1
        }
      ]
    },
    {
      "type": "whitespace",
      "children": [
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 1794,
          "lineBreaks": 1,
          "line": 40,
          "col": 2
        },
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 1795,
          "lineBreaks": 1,
          "line": 41,
          "col": 1
        }
      ]
    },
    {
      "type": "text",
      "value": "In fact, this markdown README file was generated from a README.ax file, where the functions look like markdown tags:\n\n",
      "text": "In fact, this markdown README file was generated from a README.ax file, where the functions look like markdown tags:\n\n",
      "offset": 1796,
      "lineBreaks": 2,
      "line": 42,
      "col": 1
    },
    {
      "type": "functionInvocation",
      "identifier": {
        "type": "identifier",
        "value": ">",
        "text": ">",
        "offset": 1915,
        "lineBreaks": 0,
        "line": 44,
        "col": 2
      },
      "children": [
        {
          "type": "text",
          "value": "\\<# \\{ How? \\}\n\n\\<## \\{ Syntax is separate from semantics \\} \n\nYou can see the grammar \\<a(./grammar.ne) \\{ here \\}.\n\n\\<l \\{\n\\<\\< \\{ Markdown \\<a(https://roopc.net/posts/2014/markdown-cfg/) \\{ has an ambiguous grammar \\} and therefore multiple implementations of parsing and rendering. \\}\n\\<\\< \\{ Not all programming languages have markdown parsers that offer extension points, and even when they do, those extension points often make it feel messier to write in markdown. \\}\n\\<\\< \\{ You can't arbitrarily nest tagged/transformed text in markdown, so it's inherently limited as a language. \\}\n\\}\n",
          "text": "\\<# \\{ How? \\}\n\n\\<## \\{ Syntax is separate from semantics \\} \n\nYou can see the grammar \\<a(./grammar.ne) \\{ here \\}.\n\n\\<l \\{\n\\<\\< \\{ Markdown \\<a(https://roopc.net/posts/2014/markdown-cfg/) \\{ has an ambiguous grammar \\} and therefore multiple implementations of parsing and rendering. \\}\n\\<\\< \\{ Not all programming languages have markdown parsers that offer extension points, and even when they do, those extension points often make it feel messier to write in markdown. \\}\n\\<\\< \\{ You can't arbitrarily nest tagged/transformed text in markdown, so it's inherently limited as a language. \\}\n\\}\n",
          "offset": 1919,
          "lineBreaks": 11,
          "line": 45,
          "col": 1
        }
      ]
    },
    {
      "type": "whitespace",
      "children": [
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 2516,
          "lineBreaks": 1,
          "line": 56,
          "col": 2
        },
        {
          "type": "ws",
          "value": "\n",
          "text": "\n",
          "offset": 2517,
          "lineBreaks": 1,
          "line": 57,
          "col": 1
        }
      ]
    }
  ]
}
